#### Types

- `short`: 16 (at least), 16 (usually)
- `int`: 16, 32
- `long`: 32, 32 or 64
- `long long`: 64, 64
- `char`: 8, 8, maybe signed or unsigned
- `signed char + short -> integer`, `signed + unsigned -> unsigned`
- 在函数调用中，参数是赋值（cpp为初始化），即直接复制到对应的形参中，而**忽略**了形参类型的任何类型限定符（如 `const`、`volatile` 等）；可能递归拷贝结构体。
#### UB
- `printf("%d%d", ++i, i); i = ++i + i++; i = i++ + 1;` 多次修改且未指定顺序
- `int x = 96; printf("%f\n", x/100);` 类型不对，必须严格对应
- 调用一个没有返回值的函数，其返回值是未定义的
- 访问未初始化的局部变量，其行为是未定义的
- 野指针、空指针、悬空指针（被free掉了）
- `int a[100] = {0}; delete a;` 应使用 `delete[]`
#### CPP类型转换
- `static_cast`: 类型安全的，如从基类指针/引用转换到派生类指针/引用，或者在数字类型之间转换。
- `dynamic_cast`: 用于**多态类型**的转换，通常用于转换指向基类的指针或引用到指向派生类的指针或引用。它可以在运行时检查类型是否有效。只有**有虚函数的类**才支持
- `const_cast`: 用于添加或去除对象的 `const` 限定符，如果你修改一个常量对象的内容，行为是未定义的。
- `reinterpret_cast`: 用于不同类型之间的低级别转换，通常用于指针或引用的类型转换。它可以将一个指针或引用转换成几乎任何其他类型。